#ifndef RESULTSCLASS_H
#define RESULTSCLASS_H
#include <set>
#include <iostream>
#include <map>
#include "kmerClass.h"
#include "queryClass.h"

namespace ft {


//typedef std::pair<std::set<size_t>, std::set<FlagType>> ResultsFuture;

class FTResults{
public:
    ////////////////////////////////////////////////////////////////////////
    /// \brief Results Class
    ////////////////////////////////////////////////////////////////////////
    FTResults(std::string kmer);

    ////////////////////////////////////////////////////////////////////////
    /// \brief Results Class
    ////////////////////////////////////////////////////////////////////////
    virtual ~FTResults();

    ////////////////////////////////////////////////////////////////////////
    /// \brief properties
    ////////////////////////////////////////////////////////////////////////
    ft::KmerClass _searchKmer;
    std::set<size_t> _positions;
    std::set<FlagType> _flags;

    ////////////////////////////////////////////////////////////////////////
    /// \brief getters
    ////////////////////////////////////////////////////////////////////////
    ft::KmerClass getSearchKmer();
    std::set<size_t> getPositions();
    std::set<FlagType> getFlags();

    ////////////////////////////////////////////////////////////////////////
    /// \brief setters
    ////////////////////////////////////////////////////////////////////////
    void setSearchKmer(ft::KmerClass searchKmer);
    void setPositions(std::set<size_t>);
    void setFlags(std::set<FlagType>);

    ////////////////////////////////////////////////////////////////////////
    /// \brief adders
    ////////////////////////////////////////////////////////////////////////
    void addPositions(std::set<size_t>);
    void addPosition(size_t);
    void addFlags(std::set<FlagType>);
    void addFlag(FlagType);

private:

};
}
#endif // RESULTSCLASS_H
